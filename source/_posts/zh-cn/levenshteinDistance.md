---
title: 编辑距离算法的应用
date: 2024-08-22 21:57:24
updated:
keywords:
slug: levenshtein
cover: /image/levenstain.png
top_image:
comments: false
maincolor:
categories:
  - ai 技术
tags: 工作研究
typora-root-url: ./levenshteinDistance
---

在工作中，有一个场景需要对 AI 识别的结果与预先制定的标准结果进行比对分析，并进行纠正。如何保证纠正的合理与准确，这就需要用到莱温斯坦编辑距离算法来实现了。

# 编辑距离算法介绍

编辑距离的作用主要是用来比较两个字符串的相似度的。

> 编辑距离，又称 Levenshtein 距离（莱文斯坦距离也叫做 Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。
> 在概念中，我们可以看出一些重点：编辑操作只有三种，分别是插入，删除，替换。我们有两个字符串，将其中一个字符串经过上面的这三种操作之后，得到两个完全相同的字符串付出的代价是什么就是我们要讨论和计算的。

例如：

我们有两个字符串：kitten 和 sitting:
现在我们要将 kitten 转换成 sitting
我们可以做如下的一些操作；
kitten–>sitten 将 K 替换成 S sitten–> sittin 将 e 替换成 i
sittin–> sitting 添加 g
在这里我们设置每经过一次编辑，也就是变化（插入，删除，替换）我们花费的代价都是 1。

`相似度 = 1- 编辑代价/math.Max(str1.length,str2.length)`

例如：

如果 str1=”ivan”，str2=”ivan”，那么经过计算后编辑次数等于 0。没有经过转换。
`相似度 = 1-0/Math.Max(str1.length,str2.length)=1`
如果 str1=”ivan1”，str2=”ivan2”，那么经过计算后编辑次数等于 1。str1 的”1”转换”2”，转换了一个字符，所以距离是 1，
`相似度 = 1-1/Math.Max(str1.length,str2.length)=0.8`

## 算法过程

1、str1 或 str2 的长度为 0 返回另一个字符串的长度。 if(str1.length==0) return str2.length; if(str2.length==0) return str1.length;

2、初始化(n+1)*(m+1)的矩阵 d，并让第一行和列的值从 0 开始增长。扫描两字符串（n*m 级的），如果：str1[i] == str2[j]，用 temp 记录它，为 0。否则 temp 记为 1。然后在矩阵 d[i,j]赋于 d[i-1,j]+1 、d[i,j-1]+1、d[i-1,j-1]+temp 三者的最小值。

3、扫描完后，返回矩阵的最后一个值 d[n][m]即是它们的距离。

计算相似度公式：`1-它们的距离/两个字符串长度的最大值`。

我们用字符串“ivan1”和“ivan2”举例来看看矩阵中值的状况：
1、第一行和第一列的值从 0 开始增长
![](p1.PNG)

首先我们先创建一个矩阵，或者说是我们的二维数列，假设有两个字符串，我们的字符串的长度分别是 m 和 n，那么，我们矩阵的维度就应该是(m+1)\*(n+1).
注意，我们先给数列的第一行第一列赋值，从 0 开始递增赋值。我们就得到了图一的这个样子
之后我们计算第一列，第二列，依次类推，算完整个矩阵。
我们的计算规则就是：
d[i,j]=min(d[i-1,j]+1 、d[i,j-1]+1、d[i-1,j-1]+temp) 这三个当中的最小值。
其中：str1[i] == str2[j]，用 temp 记录它，为 0。否则 temp 记为 1
我们用 d[i-1,j]+1 表示增加操作
d[i,j-1]+1 表示我们的删除操作
d[i-1,j-1]+temp 表示我们的替换操作

2、举证元素的产生 Matrix[i - 1, j] + 1 ; Matrix[i, j - 1] + 1 ; Matrix[i - 1, j - 1] + t 三者当中的最小值
![](p2.PNG)

3.依次类推直到矩阵全部生成
![](p3.png)
![](p4.png)
这个就得到了我们的整个完整的矩阵，矩阵的右下方的值 1 就是本次转换的最小代价。

# 如何应用到业务上

假设有：
检测序列 s1=[100051031, 100051046, 100051023, 100051044, 100051062, 100051381,100020872, 100020872, 100327014, 100327014, 100236304, 100236304, 100236304]
标准序列 s2=[100051031, 100051046, 100051023, 100051044, 100051062,100018653, 100051381, 100020872, 100236304, 100327014]
编辑距离算法提到有三种操作，分别是 增加、删除、替换或不变。

1、计算编辑距离数组
从动态规划计算得到的二维数组中，我们可以知道 原字符串 s1[i]，目标字符串 s2[j]，当 i、j 为任意值时的最小编辑次数。计算得到矩阵 metrix
我们可以在每一步计算编辑距离的时候，同时记录具体的操作（增加，删除，修改，不变）。

2、递归得到回溯最小编辑路径的操作序列
使用数字代表相应操作，其中 1 表示删除，2 表示增加，4 表示修改，8 表示不变
从数组右下放方最小编辑次数的位置 metrix(i,j)，开始回溯上一步的操作，回溯过程需要始终保持当前位置是最小的编辑次数。
如果当前位置的操作是 8 或 4，则回退到 metrix(i-1,j-1)；
如果当前位置操作是 2，则回退到 metrix(i,j-1)；
如果当前位置操作是 1，则回退到 metrix(i-1,j)；
重复上述步骤，直到回溯字符串的起始位置，回溯过程中记录当时的操作。这样就能得到一个最小编辑路径 trace。

![](matrix.png)

图中 op 等于操作类型，op 左边的数字表示编辑次数，为了方便查看，其他格子的 op 值没有标出来。
从 trace 我们可以得到编辑的过程，就可以对商品检测的 sku 序列，进行对应的编辑。

例如上述的例子，得到的 trace 路径为[8, 8, 8, 8, 8, 4, 4, 8, 1, 1, 1, 8, 4]，对应的语义如下：
[不变，不变，不变，不变，不变，修改，修改，不变，删除，删除，删除，不变，修改]
再次查看这两个字符数组：

- s1 [100051031, 100051046, 100051023, 100051044, 100051062, 100051381,100020872, 100020872, 100327014, 100327014, 100236304, 100236304, 100236304]
- s2 [100051031, 100051046, 100051023, 100051044, 100051062, 100018653, 100051381, 100020872, 100236304, 100327014]

验证：
对 s1 使用最小编辑路径进行操作
[100051031（不变）, 100051046 （不变）, 100051023（不变）, 100051044（不变）, 100051062（不变）, 100051381（修改为 100018653）,100020872（修改为 100051381）, 100020872 （不变）, 100327014（删除）, 100327014（删除）, 100236304（删除）, 100236304（不变）, 100236304（修改为 100327014) ]
得到 s2

## 还原结果

根据得到的最佳 trace 路径，我们可以对 AI 的检测序列进行匹配结果填写。

由于涉及工作上的信息，具体实现就不贴出来了，得到 trace 路径之后根据自己的业务需要，还是可以很容易得出自己想要的纠正结果的。
